/+module: moduleDeclaration? declaration*
    ;

moduleDeclaration: "module" identifierChain ";"
    ;

declaration: attributedDeclaration
    | importDeclaration
    | functionDeclaration
    | variableDeclaration
    | aliasThisDeclaration
    | structDeclaration
    | classDeclaration
    | interfaceDeclaration
    | unionDeclaration
    | enumDeclaration
    | aliasDeclaration
    | mixinDeclaration
    | unittest
    | staticAssertDeclaration
    | templateDeclaration
    | constructor
    | destructor
    | staticConstructor
    | staticDestructor
    | sharedStaticDestructor
    | sharedStaticConstructor
    | conditionalDeclaration
    | pragmaDeclaration
    ;

importDeclaration: "static"? "import" importList ";"
    ;

importList: singleImport ("," importList)?
    | importBindings
    ;

singleImport: (Identifier "=")? identifierChain
    ;

importBindings: singleImport ":" importBind ("," importBind)*
    ;

importBind: Identifier ("=" Identifier)?
    ;

aliasThisDeclaration: "alias" Identifier "this" ";"
    ;

structDeclaration: "struct" Identifier (templateParameters constraint? structBody | (structBody | ";"))
    ;

templateParameters: "(" templateParameterList? ")"
    ;

constraint: "if" "(" expression ")"
    ;

structBody: "{" declaration* "}"
    ;

classDeclaration: "class" Identifier (templateParameters constraint?)? (":" identifierList )? classBody
    ;

classBody: "{" (declaration | invariant)* "}"
    ;

invariant: "invariant" "(" ")" blockStatement
    ;

constructor: "this" parameters functionBody
    ;

destructor: "~" "this" "(" ")" functionBody
    ;

statement: ";"
    | nonEmptyStatement
    ;

interfaceDeclaration: "interface" Identifier (templateParameters constraint?)? (":" identifierList)? structBody
    ;

unionDeclaration: "union" Identifier ((templateParameters constraint? structBody)? | (structBody | ";"))
    ;

enumDeclaration: "enum" Identifier? (":" type )? enumBody
    ;

enumBody: ";"
    | "{" enumMember ("," enumMember?)* "}"
    ;

enumMember: Identifier
    | (Identifier | type) "=" assignExpression
    ;

nonEmptyStatement: nonEmptyStatementNoCaseNoDefault
    | caseStatement
    | caseRangeStatement
    | defaultStatement
    ;

nonEmptyStatementNoCaseNoDefault: labeledStatement
    | blockStatement
    | assignStatement
    | ifStatement
    | whileStatement
    | doStatement
    | forStatement
    | foreachStatement
    | switchStatement
    | finalSwitchStatement
    | continueStatement
    | breakStatement
    | returnStatement
    | gotoStatement
    | withStatement
    | synchronizedStatement
    | tryStatement
    | throwStatement
    | scopeGuardStatement
    | asmStatement
    | foreachRangeStatement
    | conditionalStatement
    | staticAssertStatement
    | assertStatement
    | templateMixinStatement
    | versionSpecification
    | debugSpecification
    | functionCallStatement
    | deleteStatement
    ;

labeledStatement: Identifier ":" statement
    ;

returnStatement: "return" expression? ";"
    ;

switchStatement: "switch" "(" expression ")" switchBody
    ;

switchBody: "{" (statement)+ "}"
    ;

finalSwitchStatement: "final" switchStatement
    ;

caseStatement: "case" argumentList ":" declarationsAndStatements
    ;

caseRangeStatement: "case" assignExpression ":" "..." "case" assignExpression ":" declarationsAndStatements
    ;

defaultStatement: "default" ":" declarationsAndStatements
    ;

statementNoCaseNoDefault: ";"
    | nonEmptyStatementNoCaseNoDefault
    ;

continueStatement: "continue" Identifier? ";"
    ;

breakStatement: "break" Identifier? ";"
    ;

gotoStatement: "goto" (Identifier | "default" | "case" expression?) ";"
    ;

withStatement: "with" "(" (expression | symbol | templateInstance) ")" nonEmptyStatementNoCaseNoDefault
    ;

synchronizedStatement: "synchronized" ("(" expression ")")? nonEmptyStatementNoCaseNoDefault
    ;

tryStatement: "try" nonEmptyStatementNoCaseNoDefault (catches | catches finally_ | finally_)
    ;

catches: lastCatch
    | catch_ catches?
    ;

lastCatch: "catch" nonEmptyStatementNoCaseNoDefault
    ;

catch_: "catch" "(" type Identifier? ")" nonEmptyStatementNoCaseNoDefault
    ;

finally_: "finally" nonEmptyStatementNoCaseNoDefault
    ;

throwStatement: "throw" expression ";"
    ;

scopeGuardStatement: "scope" "(" Identifier ")" nonEmptyStatementNoCaseNoDefault
    ;

asmStatement: "asm" "{" asminstruction+ "}"
    ;

asminstruction: Identifier
    | "align" IntegerLiteral
    | "align" Identifier
    | Identifier ":" asminstruction
    | Identifier asmexp
    | opcode operands
    ;

operands: operand+
    ;

register: Identifier
    | Identifier "(" IntegerLiteral ")"
    ;

opcode: Identifier
    ;

operand: asmexp
    ;

asmexp: asmlogorexp
    | asmlogorexp "?" asmexp ":" asmexp
    ;

asmlogorexp: asmlogandexp
    | asmlogandexp "||" asmlogandexp
    ;

asmlogandexp: asmorexp
    | asmorexp "&&" asmorexp
    ;

asmorexp: asmxorexp
    | asmxorexp "|" asmxorexp
    ;

asmxorexp: asmandexp
    | asmandexp "^" asmandexp
    ;

asmandexp: asmequalexp
    | asmequalexp "&" asmequalexp
    ;

asmequalexp: asmrelexp
    | asmrelexp ("==" | "!=") asmrelexp
    ;

asmrelexp: asmshiftexp
    | asmshiftexp ("<" | "<=" | ">" | ">=") asmshiftexp
    ;

asmshiftexp: asmaddexp
    | asmaddexp ("<<" | ">>" | ">>>") asmaddexp
    ;

asmaddexp: asmmulexp
    | asmmulexp ("+" | "-") asmmulexp
    ;

asmmulexp: asmbrexp
    | asmbrexp ("*" | "/" | "%") asmbrexp
    ;

asmbrexp: asmunaexp
    | asmbrexp "[" asmexp "]"
    ;

asmunaexp: asmtypeprefix asmexp
    | Identifier asmexp
    | "+" asmunaexp
    | "-" asmunaexp
    | "!" asmunaexp
    | "~" asmunaexp
    | asmprimaryexp
    ;

asmprimaryexp: IntegerLiteral
    | FloatLiteral
    | "$"
    | register
    | identifierChain
    ;

asmtypeprefix: Identifier Identifier
    | "byte" Identifier
    | "short" Identifier
    | "int" Identifier
    | "float" Identifier
    | "double" Identifier
    | "real" Identifier
    ;

pragmaDeclaration: pragmaExpression ";"
    ;

pragmaExpression: "pragma" "(" Identifier ("," argumentList)? ")"
    ;

foreachRangeStatement: "foreach" "(" foreachType ";" expression ".." expression ")" nonEmptyStatementNoCaseNoDefault
    ;

conditionalStatement: compileCondition nonEmptyStatementNoCaseNoDefault ("else" nonEmptyStatementNoCaseNoDefault)?
    ;

compileCondition: versionCondition
    | debugCondition
    | staticIfCondition
    ;

versionCondition: "version" "(" (IntegerLiteral | Identifier | "unittest" | "assert") ")"
    ;

versionSpecification: "version" "=" (Identifier | IntegerLiteral) ";"
    ;

castExpression: "cast" "(" (type | castQualifier)? ")" unaryExpression
    ;

castQualifier: "const"
    | "const" "shared"
    | "shared" "const"
    | "inout"
    | "inout" "shared"
    | "shared" "inout"
    | "immutable"
    | "shared"
    ;

debugCondition: "debug"
    | "debug" "(" (IntegerLiteral | Identifier) ")"
    ;

debugSpecification: "debug" "=" (Identifier | IntegerLiteral) ";"
    ;

staticIfCondition: "static" "if" "(" assignExpression ")"
    ;

staticAssertStatement: "static" assertStatement
    ;

assertStatement: assertExpression ";"
    ;

templateMixinStatement: "mixin" mixinTemplateName templateArguments? Identifier? ";"
    ;

mixinTemplateName: "." identifierOrTemplateChain
    | identifierOrTemplateChain
    | typeof "." identifierOrTemplateChain
    ;

functionCallStatement: functionCallExpression ";"
    ;

deleteStatement: deleteExpression ";"
    ;

assignStatement: unaryExpression assignOperator assignExpression ("," unaryExpression assignOperator assignExpression)* ";"
    | preIncDecExpression ";"
    | postIncDecExpression ";"
    ;

assignOperator: "="
    | ">>>="
    | ">>="
    | "<<="
    | "+="
    | "-="
    | "*="
    | "%="
    | "&="
    | "/="
    | "|="
    | "^^="
    | "^="
    | "~="
    ;

ifStatement: "if" "(" expression ")" nonEmptyStatementNoCaseNoDefault ("else" nonEmptyStatementNoCaseNoDefault)?
    ;

forStatement: "for" "(" (declaration | statement) expression? ";" expression? ")" nonEmptyStatementNoCaseNoDefault
    ;

initialize: ";"
    | nonEmptyStatementNoCaseNoDefault
    ;

foreachStatement: ("foreach" | "foreach_reverse") "(" foreachTypeList ";" expression ")" nonEmptyStatementNoCaseNoDefault
    ;

foreachTypeList: foreachType ("," foreachType)*
    ;

foreachType: "ref"? type? Identifier
    ;

expression: assignExpression ("," assignExpression)*
    ;

identifierOrTemplateInstance: Identifier
    | templateInstance
    ;

templateInstance: Identifier templateArguments
    ;

typeofExpression: "typeof" "(" (expression | "return") ")"
    ;

typeidExpression: "typeid" "(" (type | expression) ")"
    ;

isExpression: "is" "(" (assignExpression | (type Identifier? ((":" | "==") typeSpecialization ("," templateParameterList)?)?)) ")"
    ;

templateParameterList: templateParameter ("," templateParameter?)*
    ;

templateParameter: templateTypeParameter
    | templateValueParameter
    | templateAliasParameter
    | templateTupleParameter
    | templateThisParameter
    ;

templateTypeParameter: Identifier (":" type)? ("=" type)?
    ;

templateValueParameter: type Identifier (":" expression)? templateValueParameterDefault?
    ;

templateValueParameterDefault:  "=" ("__FILE__" | "__MODULE__" | "__LINE__" | "__FUNCTION__" | "__PRETTY_FUNCTION__" | assignExpression)
    ;

templateAliasParameter: "alias" type? Identifier (":" (type | expression))? ("=" (type | expression))?
    ;

templateTupleParameter: Identifier "..."
    ;

templateThisParameter: "this" templateTypeParameter
    ;

typeSpecialization: type
    | "struct"
    | "union"
    | "class"
    | "interface"
    | "enum"
    | "function"
    | "delegate"
    | "super"
    | "const"
    | "immutable"
    | "inout"
    | "shared"
    | "return"
    | "__parameters"
    ;

templateArguments: "!" ("(" templateArgumentList? ")" | templateSingleArgument)
    ;

templateArgumentList: templateArgument ("," templateArgument?)*
    ;

templateArgument: type
    | assignExpression
    | symbol
    ;

symbol: "."? identifierOrTemplateChain
    ;

templateSingleArgument: Identifier
    | builtinType
    | CharacterLiteral
    | StringLiteral
    | IntegerLiteral
    | FloatLiteral
    | "true"
    | "false"
    | "null"
    | "this"
    | "__DATE__"
    | "__TIME__"
    | "__TIMESTAMP__"
    | "__VENDOR__"
    | "__VERSION__"
    | "__FILE__"
    | "__LINE__"
    | "__MODULE__"
    | "__FUNCTION__"
    | "__PRETTY_FUNCTION__"
    ;

functionCallExpression: unaryExpression templateArguments? arguments
    ;

arguments: "(" argumentList? ")"
    ;

argumentList: assignExpression ("," assignExpression?)*
    ;

newExpression: "new" type ("[" assignExpression "]" | arguments)?
    | newAnonClassExpression
    ;

newAnonClassExpression: "new" arguments? "class" arguments? Identifier identifierList? classBody
    ;

deleteExpression: "delete" unaryExpression
    ;

assignExpression: ternaryExpression
    | ternaryExpression assignOperator assignExpression
    ;

ternaryExpression: orOrExpression
    | orOrExpression "?" expression ":" ternaryExpression
    ;

orOrExpression: andAndExpression
    | orOrExpression "||" andAndExpression
    ;

andAndExpression: orExpression
    | cmpExpression
    | andAndExpression "&&" (orExpression | cmpExpression)
    ;

orExpression: xorExpression
    | orExpression "|" xorExpression
    ;

xorExpression: andExpression
    | xorExpression "^" andExpression
    ;

andExpression: shiftExpression
    | andExpression "&" shiftExpression
    ;

cmpExpression: shiftExpression
    | equalExpression
    | identityExpression
    | relExpression
    | inExpression
    ;

equalExpression: shiftExpression ("==" | "!=") shiftExpression;

identityExpression: shiftExpression ("is" | "!" "is") shiftExpression;

relExpression: shiftExpression ("<" | "<=" | ">" | ">=" | "!<>=" | "!<>" | "<>" | "<>=" | "!>" | "!>=" | "!<" | "!<=") shiftExpression;

inExpression: shiftExpression ("in" | "!" "in") shiftExpression;

shiftExpression: addExpression
    | shiftExpression ("<<" | ">>" | ">>>") addExpression;

addExpression: mulExpression
    | addExpression ("+" | "-" | "~") mulExpression
    ;

mulExpression: powExpression
    | mulExpression ("*" | "/" | "%") powExpression
    ;

powExpression: unaryExpression
    | unaryExpression "^^" powExpression
    ;

unaryExpression: primaryExpression
    | "&" unaryExpression
    | "!" unaryExpression
    | "*" unaryExpression
    | "+" unaryExpression
    | "-" unaryExpression
    | "~" unaryExpression
    | preIncDecExpression
    | newExpression
    | deleteExpression
    | castExpression
    | /*unaryExpression templateArguments? arguments*/ functionCallExpression /* This causes an error in ANTLR */
    | /*unaryExpression ("++"| "--")*/  postIncDecExpression /* This causes an error in ANTLR */
    | unaryExpression "[" "]"
    | unaryExpression "[" argumentList "]"
    | unaryExpression "[" assignExpression ".." assignExpression "]"
    | unaryExpression "." identifierOrTemplateInstance
    | assertExpression
    ;

assertExpression: "assert" "(" assignExpression ("," assignExpression)? ")"
    ;

postIncDecExpression: unaryExpression ("++" | "--")
    ;

preIncDecExpression: ("++" | "--") unaryExpression
    ;

primaryExpression: identifierOrTemplateInstance
    | "." identifierOrTemplateInstance
    | type "." Identifier
    | typeofExpression
    | typeidExpression
    | "$"
    | "this"
    | "super"
    | "null"
    | "true"
    | "false"
    | "__DATE__"
    | "__TIME__"
    | "__TIMESTAMP__"
    | "__VENDOR__"
    | "__VERSION__"
    | "__FILE__"
    | "__LINE__"
    | "__MODULE__"
    | "__FUNCTION__"
    | "__PRETTY_FUNCTION__"
    | IntegerLiteral
    | FloatLiteral
    | StringLiteral
    | CharacterLiteral
    | arrayLiteral
    | assocArrayLiteral
    | "(" expression ")"
    | isExpression
    | lambdaExpression
    | functionLiteralExpression
    | traitsExpression
    | mixinExpression
    | importExpression
    ;

whileStatement: "while" "(" expression ")" statementNoCaseNoDefault
    ;

doStatement: "do" blockStatement "while" "(" expression ")" ";"
    ;

blockStatement: "{" declarationsAndStatements? "}"
    ;

declarationsAndStatements: (declaration | statementNoCaseNoDefault)+
    ;

functionDeclaration: memberFunctionAttribute* (type | "auto" "ref"? | "ref" "auto"?) Identifier (templateParameters parameters memberFunctionAttribute* constraint? functionBody | parameters memberFunctionAttribute* (functionBody | ";"))
    ;

type: typeConstructors? type2
    ;

type2: type3 typeSuffix?
    | type2 typeSuffix
    ;

type3: builtinType
    | symbol
    | typeof ("." identifierOrTemplateChain)?
    | typeConstructor "(" type ")"
    ;

identifierOrTemplateChain : identifierOrTemplateInstance ("." identifierOrTemplateInstance)*
    ;

typeSuffix: "*"
    | "[" (type | assignExpression)? "]"
    | ("delegate" | "function") parameters memberFunctionAttribute*
    ;

builtinType: "bool"
    | "byte"
    | "ubyte"
    | "short"
    | "ushort"
    | "int"
    | "uint"
    | "long"
    | "ulong"
    | "char"
    | "wchar"
    | "dchar"
    | "float"
    | "double"
    | "real"
    | "ifloat"
    | "idouble"
    | "ireal"
    | "cfloat"
    | "cdouble"
    | "creal"
    | "void"
    ;

typeConstructors: typeConstructor+
    ;

typeConstructor: "const"
    | "immutable"
    | "inout"
    | "shared"
    ;

typeof: "typeof" "(" (expression | "return") ")"
    ;

parameters: "(" ((parameter ("," parameter)*)? ("," "...")? | "...") ")"
    ;

parameter: parameterAttribute* type (Identifier? "..." | (Identifier ("=" assignExpression)?))?
    ;

parameterAttribute: "auto"
    | "final"
    | "in"
    | "lazy"
    | "out"
    | "ref"
    | "scope"
    | typeConstructor
    ;

functionAttribute: "nothrow"
    | "pure"
    | atAttribute
    ;

memberFunctionAttribute: "const"
    | "immutable"
    | "inout"
    | "shared"
    | functionAttribute
    ;

functionBody: blockStatement
    | (inStatement | outStatement | outStatement inStatement | inStatement outStatement)? bodyStatement
    ;

inStatement: "in" blockStatement
    ;

outStatement: "out" ("(" Identifier ")")? blockStatement
    ;

bodyStatement: "body" blockStatement
    ;

aliasDeclaration: "alias" (aliasInitializer ("," aliasInitializer)* | type declarator) ";"
    ;

aliasInitializer: Identifier "=" type
    ;

variableDeclaration: storageClass? type declarator ("," declarator)* ";"
    | autoDeclaration
    ;

autoDeclaration: storageClass Identifier "=" initializer ("," Identifier "=" initializer)* ";"
    ;

storageClass : "abstract"
    | "auto"
    | typeConstructor
    | "deprecated"
    | "enum"
    | "extern"
    | "final"
    | "nothrow"
    | "override"
    | "pure"
    | "__gshared"
    | atAttribute
    | "scope"
    | "static"
    | "synchronized"
    ;

declarator: Identifier declaratorSuffix? ("=" initializer)?
    ;

declaratorSuffix: "[" (type | assignExpression)? "]"
    ;

mixinDeclaration: mixinExpression ";"
    ;

identifierList: Identifier ("," Identifier)*
    ;

identifierChain: Identifier ("." Identifier)*
    ;

attributedDeclaration: attribute (":" | declaration | "{" declaration* "}")
    ;

attribute: linkageAttribute
    | alignAttribute
    | pragmaExpression
    | protectionAttribute
    | deprecated
    | "extern"
    | "final"
    | "synchronized"
    | "override"
    | "abstract"
    | "const"
    | "auto"
    | "scope"
    | "__gshared"
    | "shared"
    | "immutable"
    | "inout"
    | "static"
    | "pure"
    | "nothrow"
    | atAttribute
    ;

linkageAttribute: "extern" "(" Identifier "++"? ")"
    ;

atAttribute: "@" (Identifier | "(" argumentList ")" | functionCallExpression)
    ;

alignAttribute: "align" ("(" IntegerLiteral ")")?
    ;

protectionAttribute: "private"
    | "package"
    | "protected"
    | "public"
    | "export"
    ;

deprecated: "deprecated" ("(" assignExpression ")")?
    ;
+/
traitsExpression: "__traits" "(" Identifier "," traitsArgument ("," traitsArgument)* ")"
    ;

traitsArgument: assignExpression
    | type
    ;

mixinExpression: "mixin" "(" assignExpression ")"
    ;

importExpression: "import" "(" assignExpression ")"
    ;

unittest: "unittest" blockStatement
    ;

staticAssertDeclaration: staticAssertStatement
    ;

templateDeclaration: "template" Identifier templateParameters constraint? "{" declaration+ "}"
    ;
/+
staticConstructor: "static" "this" "(" ")" functionBody
    ;

staticDestructor: "static" "~" "this" "(" ")" functionBody
    ;

sharedStaticDestructor: "shared" "static" "this" "(" ")" functionBody
    ;

sharedStaticConstructor: "shared" "static" "~" "this" "(" ")" functionBody
    ;

conditionalDeclaration: compileCondition (declaration | "{" declaration* "}") ("else" (declaration | "{" declaration* "}"))?
    ;

arrayInitializer: "[" arrayMemberInitializations? "]"
    ;

arrayMemberInitializations: arrayMemberInitialization ("," arrayMemberInitializations?)*
    ;

arrayMemberInitialization: (assignExpression ":")? nonVoidInitializer
    ;

initializer: "void"
    | nonVoidInitializer
    ;

nonVoidInitializer: assignExpression
    | arrayInitializer
    | structInitializer
    ;

structInitializer: "{" structMemberInitializers? "}"
    ;

structMemberInitializers: structMemberInitializer ("," structMemberInitializer?)*
    ;

structMemberInitializer: (Identifier ":")? nonVoidInitializer
    ;

lambdaExpression: (Identifier | parameters functionAttribute* ) "=>" assignExpression
    ;

functionLiteralExpression: (("function" | "delegate") type?)? (parameters functionAttribute*)? functionBody
    ;

arrayLiteral: "[" argumentList "]"
    ;

assocArrayLiteral: "[" keyValuePairs "]"
    ;

keyValuePairs: keyValuePair ("," keyValuePair)*
    ;

keyValuePair: assignExpression ":" assignExpression
    ;
+/
